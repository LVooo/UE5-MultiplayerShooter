# UE5-MultiplayerShooter
## 开发日记：
---
## 一、项目创建
### 1. 加入插件

### 2. 资源导入

### 3. 动画重定向
使用骨骼约束系统（IK Rig）和骨骼重定向器（IK Retargeter）

### 4. 角色创建
移动方向：
- pitch：绕x轴（俯仰）
- yaw：绕z轴（左右方向旋转）
- roll：绕y轴（竖直方向旋转）

### 5. 角色动画

### 6. 无缝传送和大厅
1) Non-Seamless Travel(非无缝传送)：客户端从服务器端断开连接，客户端重连至相同服务器。发生情况：第一次加载地图，第一次连接至服务器，当结束或开始一个多人游戏。  
2) Seamless Travel（无缝切换）：客户端无需从服务器断开连接，避免了重联时遇到的网络问题，更加丝滑。在`Game Mode`中启用，需要一个transition map，这个地图需要已经被加载完成（这样就省去了同时存在两张大地图的资源消耗）。 

### 7. 网络角色
分别有以下几种不同的网络角色：
- `ENetRole::ROLE_Authority`: 服务器上的权威角色
- `ENetRole::ROLE_SimulatedProxy`: 客户端上看到的其他玩家控制的角色
- `ENetRole::ROLE_AutonomousProxy`: 自己客户端上可控制的角色
- `ENetRole::ROLE_None`: 没有定义角色的actor

local role和remote role的区别：
- local role：在客户端上显示的为控制的角色为`Autonomous`和其他客户端上的角色`Simulated`；而在服务器端角色显示都为`Authority`
- remote role：在客户端上显示的为在服务器端的网络角色即`Authority`；而在服务器端则显示控制的角色为`Autonomous`和相应的`Simulated`


## 二、武器
### 1. 创建武器类

### 2. 拾取武器显示

### 3. 武器复制变量
在网络系统中注册了可复制的变量，解决了只能在服务端显示拾取武器控件的问题，能通过服务端复制武器到客户端，使用`DOREPLIFETIME_CONDITION`来限制只在有所有权的服务端或客户端复制武器，其他客户端不会同步该武器。  
并且通过委托函数（通过宏设置`ReplicatedUsing`）来触发回调函数`OnRep_`（里面能够通过参数保存原属性的旧值）来设置人物与武器重叠时的拾取武器控件的显示与关闭。

### 4. 装备武器
- 使用了Actor Component来创建一个在人物角色上的新组件用来装备武器
- 为`CombatComponent`添加人物角色的友元类以将所有访问权限暴露给角色类
- 在多个类中为了获取私有变量，创建内联函数`FORCEINLINE`的get或set函数来减少性能开销。在内联函数中，函数体的代码被肢解插入到调用该函数的地方，因此不需要进行函数调用的相关开销，如压栈、跳转、返回值处理等。相比于函数调用，内联函数的执行速度更快。

### 5. 远程过程调用（RPC）
1) Remote Procedure Call是指在客户端和服务器之间发送函数调用消息的机制。当客户端需要通知服务器执行某个函数时，客户端可以通过RPC将函数调用消息发送给服务器，并在服务器上执行该函数；服务器同理。  
2) RPC分为可靠的与不可靠的：
   - 可靠：确保RPC调用被成功接收并处理，如果网络出现问题会尝试重传RPC调用，直到成功处理。基于TCP协议，保证了数据的可靠性和正确性，比如玩家角色位置的同步
   - 不可靠：可能会在网络中被丢失。基于UDP协议，用于快速传输RPC调用，但不保证数据的可靠性和正确性；可能会出现数据丢失或顺序错乱等问题，比如玩家角色的伤害计算
3) 在UE中，对于声明了RPC的函数，需要在其后面添加一个函数名为原函数名+`_Implementation`的实现函数，用于处理服务器上实际执行该RPC所需的逻辑。这样设计的原因是：RPC系统基于反射机制（在程序运行时动态调用函数）实现的，使得RPC函数的调用和实现可以分离，从而更好的实现了代码解耦性和可维护性。
4) 通过将变量设置为replicated，如果这个变量在服务端**发生改变**（如果没有发生变化则不起作用）并设置为true，在客户端上会被复制也设置为true，此时调用Rep_Notify可以在所有客户端上复刻服务端上的动作。

### 6. 装备武器动画姿势
因为上面仅在服务器端给武器类中的EquippedWeapon赋值了，客户端中的依然为null，这时就需要给武器类中的EquippedWeapon也设置为Replicated。  
一旦涉及这个过程都需要为该变量加上`UPROPERTY(Replicated)`，并重写`GetLifetimeReplicatedProps`虚函数。

### 7. 下蹲
UE中自带Crouch和UnCrouch内置函数（考虑了多人在线游戏因素），这个内置函数中`bIsCrouched`变量是可复制的所以可以复制到所有客户端，并且还实现了如**重置胶囊体**和移动速度切换等，大大减少了重复造轮子的时间。

Tilde符号即~，可以用作运行游戏时打开控制台的快捷键；能够查看和修改游戏状态，执行各种命令（如添加物体，碰撞检测等）

### 8. 瞄准
在`CombatComponent`中把诸如`EquippedWeapon`, `bAiming`等变量都设置为`Replicated`；这些属性将被自动在客户端上复制，从而实现服务器与客户端之间的同步。这里使用`ServerSetAiming`作为RPC会在客户端上调用服务器上的函数，服务器将更该应用于自己的状态并分发给所有已连接的客户端进行同步，因为该函数被标记为了`Server Reliable`所以只有服务器可以调用它并建立可靠的RPC服务。

>计算旋转偏移Yaw Offset过程：
1) 获取角色的基础瞄准旋转（Base Aim Rotation），即没有偏移时的瞄准旋转；
2) 获取角色的运动方向，通常是角色的速度向量，然后将其转换为一个旋转矢量；
3) 计算角色的运动方向与瞄准方向之间的旋转差（Delta Rotation）；
4) 将旋转差转换为一个浮点数值，通常是旋转差的Yaw轴（水平旋转轴）分量；
5) 使用差值算法（如线性插值或插值函数）逐渐调整Yaw Offset的值，使其向目标值靠近。

如：当玩家瞄准时，游戏会计算出身体需要旋转的角度，然后将这个角度缓慢地应用到角色的旋转中。这样，身体的旋转速度就可以逐渐与头部的旋转速度同步，从而保证射击时枪口不会偏离目标。  
在第三人称射击游戏中，角色的枪口和准心通常不在同一位置，而且准心的位置通常是固定的，不会随着角色的移动而变化。另外，角色身体的旋转和移动方向通常也不是完全与准心对齐的，这就导致了准心和角色的瞄准方向存在差异。为了让玩家能够更准确地瞄准，需要通过瞄准偏移来修正这种差异，让准心与实际瞄准方向对齐。

### 9. 横向移动以及身体倾斜
通过旋转root角度制作lean的动画，在混合空间blendspace中填入。  
为了配合身体的旋转，需要在服务端和客户端均禁用`OrientationRoration`（使用了RepNotify）  
计算身体倾斜lean时，记录了上一帧角色朝向，通过与当前帧的角色朝向的差值计算出朝向的变化率，即每秒的旋转角度；接着通过插值（Interpolation）计算出当前帧的身体倾斜状态并将其限制在-90到90度之间。对于横向则使用了`RInterpTo`使其有一个平滑的过渡。

### 10. 瞄准偏移
当人物处于装备武器站立状态时，此时人物上半身瞄准状态应该跟随鼠标移动，而下半身应保持静止状态。  
>当客户端发送Pitch（水平方向的旋转即俯仰视，限制在了-90到90度之间）到服务端时或服务器分发给客户端时，需要经过一个函数将角度压缩成size更小的short类型；因此负角度就会转换成[0->360)的度数，再通过与0xFFFF比特相与映射到[0->65536)，再传到服务器或其他客户端时再解压缩到[0->360)之间的度数，这就会造成当人物俯视时在其他客户端显示为仰视。

使用了Cashed Pose来分别存储我们装备武器后的身体以及瞄准姿态时的身体，使用layered blend按照spine_01将身体的上下部分分开；使用缓存姿势时，可以利用已经存在的动画资源，并通过设置适当的姿势转换规则来动态地生成动画，从而提高运行效率。另外，Cached Pose还支持在多个线程上进行计算，从而进一步提高效率。

**FABRIK IK（反向运动学）**，以使角色的左手到左肩这一部分（Solver）根据末端执行器右手（已Attachment绑定武器的transform以骨骼为参考系）能够自然地移动并正确地与手持枪械处于正确位置。在 Fabric IK 中，可以根据 end effector 的位置来调整 IK solver 的目标位置，以便更好地适应角色的运动和变化。 

### 11. 人物静止持枪旋转
新建了一个头文件专门存储转动的枚举类型，分别为：向左转，向右转，不转。为了使枪口方向在旋转90度过后角色跟随旋转；新建了一个插值InterpAO_Yaw，当它不断趋近于0度时，在小于一定阈值时使人物平滑过渡并不再处于旋转状态。

### 12. 网络更新频率
在进行多客户端测试时会发现，当在其他非控制客户端显示角色动画时，会产生抖动问题，解决方法：
- 针对人物骨骼旋转的Clamp中开启Interp Result，将旋转结果限制在一定范围内，避免角度值过大或过小出现不合理旋转效果
- 设置角色的网络更新频率（常用值为66）和最小网络更新频率（常用值为33）
- 更改配置文件中的DefaultEngine，设置NetServerMaxTickRate = 60

### 13. 添加脚步声和跳跃音效
在行走动画上添加Notify Track，使用Sound Notifies可以在所有客户端上的角色正常同步运行。  
使用Notify Sound Sync用来创建同步声音事件，用于处理网络同步音频问题。  
同时给动画帧数上添加音效时需注意按总长规律添加，否则重复循环播放会造成音画不同步问题。


## 三、武器开火
### 1. 武器开火类别
Projectile vs Hitscan：  
投射物攻击方式：
- 发射一个投掷物projectile
- 有一个速度
- 有/没有重力（榴弹炮或火箭筒）
- 碰撞事件
- tracer particles轨迹粒子

射线追踪方式：
- line trace射线追踪
- 即时命中
- Beam particles光束粒子

### 2. 开火动画
为每个开火动画加上additive animation，为了在原有动画姿势和骨骼不变的情况下播放开火动画。

### 3. 实现多客户端实现开火效果
如果单单使用Server RPC只会在服务器上实现开火效果，而不会分发到各客户端上；这是因为之前通过Server RPC实现的服务器分发客户端效果使用了Replicated变量的效果，但Replicated变量只有在发生改变的时候才会成功复制到各客户端上，然而如果我们想实现自动开火即bFireButtonPressed一直为true，则它不会复制到各个客户端上，只会在服务端显示。  
此时引进了**NetMulticast**这个RPC通信技术，当它在服务端被触发时，会分发到服务端以及所有客户端上，很好的并且十分简洁的帮我们实现了网络传递的效果；但如果它在客户端被触发则仅会在被触发的客户端上实现，所以需要借用一层ServerFire函数使其先在服务端上被触发。

### 4. 命中目标
新建了一个私有变量HitTarget，通过TraceUnderCrosshairs为其赋值。设置viewport位置屏幕中央转换为world世界坐标系后通过linetrance设置HitTarget。

### 5. 实现多客户端命中事件
由于RPC调用需要占用网络带宽，我们不能为所有的replicated变量做RPC调用，此时需要采用其他更为高效的办法；这时我们发现Destroy()函数里实现了广播效果，所以在重写后的Destroy()函数中加入命中产生的例子效果和音效，在里面实现服务端到所有客户端的传递。

### 6. 子弹壳类
为每个武器添加统一子弹壳名的socket，在总weapon类中添加sub子弹壳变量，为了给继承总武器类的不同的枪械配置不同的弹壳类。相当于简易版的开火flash socket实现。

需要设置弹壳与摄像机的碰撞为Ignore，否则会产生镜头与弹壳碰撞畸变问题  
同样需要设置Hit Event（蓝图中的命名与C++中不同）

弹壳掉落声音：设置音效attenuation回声的inner radius为200（播放全部声音），falloff distance为1500指声音传播的距离，当距离超过该值时，声音的音量和衰减程度会逐渐减小，直至听不到为止。


## 四、武器瞄准机制
### 1. HUD和player controller